jmp INIT

.include "TWI_1.inc"

.dseg 
		.org 0x200	//Organisera viktigt!
DATA:	.byte 1 // Plats i ESRAM
ENTAL:	.byte 1 // Plats i ESRAM
TIOTAL:	.byte 1 // Plats i ESRAM


		.equ ADDRESS_1 = $25 // RIGHT aka ENTAL
		.equ ADDRESS_2 = $24 // LEFT aka TIOTAL
		.def DELAY_REG = r24 // För DELAY
.cseg

TABLE:
		.db $3F, $6, $5B, $4F, $66, $6D, $7D, $7, $7F, $67
			//0,  1,  2,  3,   4,   5,   6,   7,   8,   9

//------------------------------------------------------------------------------
////////////////////// RUTINER FÖR ATT FÖRBEREDA PROCESSEN ////////////////////
//-------------------------------------------------------------------------------
INIT:
		call TWI_INIT // Förbereder TWI
		call RESET_POINTER // Z pekaren (r30 & r31) pekar på första värdet i TABLE, $3F
		call START_SCORE //Skickar ut 0 till sjusegment
		call CLEAR_LOCATION // Rensar ev. felvärden för ENTAL, TIOTAL i esram, samt register

//-----------------------------------------------------------------------------
/*//////////////////// MAIN //////////////////////////////////////////////////
1. SKicka ut värdet i pekaren												//
2. Är värdet i ENTAL = 11?													//
	Nej -> Inkremera entalssegment											//
	Ja -> Inkremera tiotalssegment			
*/////////////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------------------
MAIN:
		call DELAY
		cpi r22, 9
		brne CONTINUE
		call KILLSCREEN

		CONTINUE:
		call COUNT_ENTAL
		lds r21, ENTAL
		cpi r21, 11 
		brne SKIP_TIO
		CALL RESET_RIGHT
		CALL COUNT_TIOTAL
		call RESET_POINTER
		inc r22
			
		SKIP_TIO:

jmp MAIN 
//--------------------------------------------------------------------------------------		

COUNT_ENTAL:
		lds r21, ENTAL
		inc r21
		sts ENTAL, r21
		lpm r23, Z+
		call SEND_RIGHT
		ret
//---------------------------------------------------

COUNT_TIOTAL:
		push ZL
		push ZH
		call RESET_POINTER
		lds r21, TIOTAL
		inc r21
		add ZL, r21
		sts TIOTAL, r21
		lpm r23, Z+
		call SEND_LEFT
		clr r21
		sts ENTAL, r21
		lds r21, ENTAL
		pop ZH
		pop ZL
		ret

//---------------------------------------------------
////////////////////// BYGGBLOCK ////////////////////
//---------------------------------------------------
	
SEND_LEFT: // Addresserar vänster sjusegment (Tiotal)
		ldi r20, ADDRESS_2 // TWI Address $24
		sts DATA, r23 // Innehåller info om vad som ska skickas ut
		call TWI_SEND // Rutin för utskick med TWI
		ret

SEND_RIGHT: // Addresserar höger sjusegment (Ental)
		ldi r20, ADDRESS_1 // TWI Address $25
		sts DATA, r23	// Innehåller info om vad som ska skickas ut
		call TWI_SEND // Rutin för utskick med TW
		ret			

START_SCORE: //Skicka 0 0 till segmenten
		ldi r23,$3F // Värde som ska skickas, $3F = 0
		call SEND_LEFT // Skickar data till vänster sjusegment
		call SEND_RIGHT // Skickar data till höger sjusegment
		ret

RESET_RIGHT: //Skicka 0 till högersegment (ental)
		ldi r23,$3F // Värde som ska skickas, $3F = 0
		call SEND_RIGHT // Skickar data till höger sjusegment
		ret

RESET_POINTER: // Laddar pekare med address till tabell
		ldi ZH, HIGH(TABLE*2)	//r30
		ldi ZL, LOW(TABLE*2)		//r31
		ret


CLEAR_LOCATION:
	/*	push r24
		push r23
		push r22
		push r21
		push r20
		push r16
		push ZL
		push ZH*/
		clr r22 // r22 = 0
		clr r21  // r21 = 0
		sts ENTAL,r21 // Spara värde i ESRAM
		sts TIOTAL, r21 // Spara värde i ESRAM
		ret

KILLSCREEN:
		ldi r23, $00
		call SEND_LEFT
		call SEND_RIGHT
		call DELAY
		ldi r23, $67
		call SEND_LEFT
		call SEND_RIGHT
		call DELAY
		jmp KILLSCREEN 

		ret


DELAY:
		//Delay 1 second
DELAY_SECOND: ; For CLK(CPU) = 1 MHz
		ldi r21,50 ; One clock cycle;
DELAY1_ONE:
		ldi r22,255 ; One clock cycle
DELAY2_ONE:
		ldi r23,252 ; One clock cycle
DELAY3_ONE:
		dec r23 ; One clock cycle
		brne Delay3_ONE ; Two clock cycles when jumping to Delay3, 1 clock when continuing to DEC

		dec r22 ; One clock cycle
		brne Delay2_ONE ; Two clock cycles when jumping to Delay2, 1 clock when continuing to DEC

		dec r21 ; One clock Cycle
		brne Delay1_ONE ; Two clock cycles when jumping to Delay1, 1 clock when continuing to RET*/
		ret
