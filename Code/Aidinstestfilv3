

		
		jmp		INIT_FUNCTION

		.org	0x250

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CSEG & DSEG
		.dseg 

		VMEM: .byte 96

		.equ MOSI = PB3
		.equ MISO = PB4
		.equ SCLK = PB5
		.equ SPI_DDR = DDRB
		.equ CS = PB2

LCD_DATA:	
		.byte 1
LCD_DATA2:	
		.byte 1 
DATA:		
		.byte 1

		.cseg  
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//DAmatrix - Character, obstacle & floor
OBSTICLE:
		.db 0b00000000, 0b00000000, 0b00000000, 0b00000000 //HÖGER
		.db 0b00111000, 0b00000000, 0b00000000, 0b10011111 //MITTEN
		.db 0b00000000, 0b00000000, 0b00000000, 0b00000010 //VÄNSTER

FLOOR:
		.db 0b00000000, 0b11111111, 0b00000000, 0b01111111
		.db 0b00000000, 0b11111111, 0b00000000, 0b01111111
		.db 0b00000000, 0b11111111, 0b00000000, 0b01111111
DINO_IDLE: 
		.db 0b00000000, 0b00000000, 0b00000000, 0b00000000 //HÖGER
		.db 0b00000000, 0b00000000, 0b00000000, 0b00000000 //MITTEN
		.db 0b01100000, 0b01100000, 0b01100000, 0b10001111 //VÄNSTER

DINO_JUMP1: 
		.db 0b00000000, 0b00000000, 0b00000000, 0b00000000 //HÖGER
		.db 0b00000000, 0b00000000, 0b00000000, 0b00000000 //MITTEN
		.db 0b01100000, 0b01100000, 0b01100000, 0b11000111 //VÄNSTER

DINO_JUMP2: 
		.db 0b00000000, 0b00000000, 0b00000000, 0b00000000 //HÖGER
		.db 0b00000000, 0b00000000, 0b00000000, 0b00000000 //MITTEN
		.db 0b01100000, 0b01100000, 0b01100000, 0b11100011 //VÄNSTER

DINO_JUMP3: 
		.db 0b00000000, 0b00000000, 0b00000000, 0b00000000 //HÖGER
		.db 0b00000000, 0b00000000, 0b00000000, 0b00000000 //MITTEN
		.db 0b01100000, 0b01100000, 0b01100000, 0b11110001 //VÄNSTER

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TEXTONE: 
		.db		"NEW GAME STARTED ", $00
TEXTTWO: 
		.db		"   GAME OVER!    ",$00
TEXTTHREE:
		.db		" PRESS TO START  ",$00

		.equ	ADDR_LCD = $20 
		.equ	SLA_LCD_W = (ADDR_LCD << 1) | 0 
		.equ	SLA_LCD_R = (ADDR_LCD << 1) | 1 
		.equ	FN_SET = $2B 
		.equ	E_MODE = $06
		.equ	DISP_ON = $0F
		.equ	LCD_CLR = $01
		.equ	E = $01
		.equ	HOME = $02
		.equ	RS = PB0

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
INIT_FUNCTION:
		call	TWI_INIT
		call	LCD_INIT
		call	SPI_MASTER_INIT
		sei
		clr		r16
		clr		r17
		call	SRAMCLEAR
READY_NOW:
		call	LCD_READY
		call	BUTTON_R
		//call	LCD_GAMESTART
		call	LCD_GAMEOVER
		jmp		MAIN

TWI_INIT: 
		ldi		r16, 100
		sts		TWBR, r16
		ldi		r16, (0<<TWINT) | (1<<TWEN)
		sts		TWCR,r16
		ret

LCD_INIT:															//Underprogram för förberedelse av LCD-display
		call	WAIT												//Kallar på rutin med 4 millisekunders delay
		ldi		r16,$30												//Magin som gör att siffror mellan 0-9 fungerar - BCD-kodar från ASCII 
		call	LCD_WRITE4
		call	LCD_WRITE4
		call	LCD_WRITE4
		ldi		r16,$20												//Magin som gör att siffror mellan 0-9 fungerar - BCD-kodar från ASCII
		call	LCD_WRITE4
		ldi		r16,FN_SET											//4-bit mode, 2 line, 5x8 font
		call	LCD_COMMAND											//Kallar på rutin som skickar displaykommandon
		ldi		r16,DISP_ON											//Display on, cursor on, cursor blink
		call	LCD_COMMAND											//Kallar på rutin som skickar displaykommandon
		ldi		r16,LCD_CLR											//Clear display
		call	LCD_COMMAND											//Kallar på rutin som skickar displaykommandon
		ldi		r16,E_MODE											//Increment cursor, no shift
		call	LCD_COMMAND											//Kallar på rutin som skickar displaykommandon
		clr		r16													//Rensar register r16 för att förhindra tecken vid nästa rad
		ret

SPI_MASTER_INIT: // Enable spi_spcr, sätta att vi är master, sänka hastigheten (Fosc/128)= sänka till långsamste hastigheten
		ldi		r17, (1<<MOSI)|(1<<SCLK)|(1<<PB2)
		out		SPI_DDR, r17
		ldi		r17, (1<<SPE) | (1<<MSTR) | (1<< SPR0)
		out		SPCR, r17
		ret

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
MAIN:

//sbic PIND, PD1
//call	SRAMCLEAR
Call FLOORCHARACTERIDLE 
//call	BUTTON_L
//Call CHARACTER_JUMP

//sbic PIND, PD1
//call	FLOORCHARACTERLOADER
//call BUTTON_L
jmp MAIN
//jmp MAIN 



FLOORCHARACTERIDLE: 

Call FLOORCHARACTERLOADER
sbic	PIND,PD1
jmp		FLOORCHARACTERIDLE
jmp		CHARACTER_JUMP
ret

FLOORCHARACTERLOADER: 

Call FLOOR_IDLE
Call CHARACTER_IDLE 
ret


/*
		//call	FLOOR_IDLE
		call	CHARACTER_IDLE
		//call	LOAD_FLOOR
		call	BUTTON_L
		call	FLOOR_IDLE
		//call	LOAD_FLOOR
		//call	UDED_SON
		jmp		MAIN
		//SEND_LINE
*/
UDED_SON:														//TEST FÖR NÄR SPELET ÄR "IGÅNG"
		call	LCD_GAMEOVER
		call	BUTTON_R
		jmp		READY_NOW

BUTTON_GO:
		sbic	PIND,PD1
		jmp		BUTTON_GO
		call	LCD_CLEAR
		jmp		LCD_GAMESTART

FLOOR_IDLE:
		call	LOAD_FLOOR
		call	SEND_MATRIX	
		ret

CHARACTER_IDLE:
		call	LOAD_DINO_IDLE
		call	SEND_MATRIX
	//	call	LOAD_FLOOR
		//call	SEND_MATRIX
		ret

BUTTON_R: 
		sbic	PIND, PD0 //PD0 är för höger knapp (tror jag)
		jmp		BUTTON_R
		ret

BUTTON_L: 
		sbic	PIND, PD1 //PD0 är för höger knapp (tror jag)
		jmp		BUTTON_L
CHARACTER_JUMP:
	//	call	BEEP_LOOP
		call	LOAD_DINO_JUMP1
		call	SEND_MATRIX
		call	DELAY_HALFHALF
		Call	FLOOR_IDLE
		call	SEND_MATRIX
		call	LOAD_DINO_JUMP2
		call	SEND_MATRIX
		call	DELAY_HALFHALF
		Call	FLOOR_IDLE
		call	SEND_MATRIX
		call	LOAD_DINO_JUMP3
		call	SEND_MATRIX
CHARACTER_FALL:
		call	DELAY_HALFSECOND
		call	LOAD_DINO_JUMP2
		call	SEND_MATRIX
		call	DELAY_HALFSECOND
				Call FLOOR_IDLE
		call	SEND_MATRIX
		call	LOAD_DINO_JUMP1
		call	SEND_MATRIX
		call	DELAY_HALFSECOND
		Call FLOOR_IDLE
		call	SEND_MATRIX
		call	LOAD_DINO_IDLE
		call	SEND_MATRIX
		call	DELAY_HALFSECOND
				Call FLOOR_IDLE
		call	SEND_MATRIX
CHARACTER_RETURN:
		jmp		MAIN
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//NEW_GAME & GAME_LOST
NEW_GAME:
		ldi		r18,0
NEW_GAME_LOOP:
		sbi		PORTD,PD4
		sbi		PORTD,PD5
		call	BEEP_LOOP
		call	WAIT
		cbi		PORTD,PD4
		cbi		PORTD,PD5
		inc		r18
		cpi		r18,1
		breq	EXIT
		jmp		NEW_GAME_LOOP

LOST_GAME:
		ldi		r18,0
LOST_GAME_LOOP:	
		sbi		PORTD,PD5
		cbi		PORTD,PD4
		call	BEEP_LOOP
		call	WAIT
		sbi		PORTD,PD4
		cbi		PORTD,PD5
		call	BEEP_LOOP1
		call	BEEP_LOOP1
		call	WAIT
		cbi		PORTD,PD5
		cbi		PORTD,PD4
		inc		r18
		cpi		r18,1
		breq	EXIT
		jmp		LOST_GAME_LOOP

EXIT:
		ret
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
//Högtalare - BEEP LOOPS
BEEP_LOOP:
		ldi		r17,240
BEEP_READY:
		dec		r17
		cpi		r17,0
		breq	NOBEEP
BEEP:		
		call	FREQUENCY_LOAD1	
		sbi		PORTB,PB1
		sbi		DDRB,1
		call	WAIT
		cbi		PORTB,PB1
		jmp		BEEP_READY

NOBEEP:
		cbi		PORTB,PB1
		cbi		DDRB,1
		ret

BEEP_LOOP1:
		ldi		r17,100
BEEP_READY1:
		dec		r17
		cpi		r17,0
		breq	NOBEEP
BEEP1:		
		call	FREQUENCY_LOAD2	
		sbi		PORTB,PB1
		sbi		DDRB,1
		call	WAIT
		cbi		PORTB,PB1
		jmp		BEEP_READY1

NOBEEP1:
		call	WAIT
		cbi		PORTB,PB1
		cbi		DDRB,1
		call	WAIT
		ret
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//HÖGTALARE - DELAY & FREQUENCY
WAIT:															
		sbiw	r24,4															//4.1 ms delay											
		brne	WAIT
		ret

FREQUENCY_LOAD1:																//64.20 mikrosekunder - 15600 Hz
		ldi		r16,255
FREQUENCY_1:
		dec		r16
		cpi		r16,0
		brne	FREQUENCY_1
		ret

FREQUENCY_LOAD2:																//25.55 mikrosekunder - 39000 Hz
		ldi		r16,100
FREQUENCY_2:
		dec		r16
		cpi		r16,0
		brne	FREQUENCY_2
		ret
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//LCD
LCD_GAMESTART: 
		ldi		ZH, HIGH(TEXTONE*2)
	    ldi		ZL, LOW(TEXTONE*2) 
		call	LCD_LINE_PRINT
		call	NEW_GAME
		ret 

LCD_GAMEOVER:
        ldi		ZH, HIGH(TEXTTWO*2)
		ldi		ZL, LOW(TEXTTWO*2)
		call	LCD_LINE_PRINT
		call	LOST_GAME
		ret

LCD_READY:
		ldi		ZH,HIGH(TEXTTHREE*2)
		ldi		ZL,LOW(TEXTTHREE*2)
		call	LCD_LINE_PRINT
		ret

LCD_LINE_PRINT:
		 call LCD_HOME
		 call LCD_PRINT 
		 ret

LCD_PRINT: 
		lpm r16, Z+
		cpi r16, $00
		breq LCD_PRINT_DONE
		call LCD_ASCH 
		rjmp LCD_PRINT

LCD_PRINT_DONE:
		ret

LCD_ASCH:
		call LCD_SEND_PREP
		lds r16, LCD_DATA
		ori r16, $01
		sts LCD_DATA, r16 
		lds r16, LCD_DATA2
		ori r16, $01 
		sts LCD_DATA2, r16
		call LCD_SEND
		ret 
	
LCD_COMMAND:
		call LCD_SEND_PREP
		lds r16, LCD_DATA
		andi r16, $FE
		sts LCD_DATA, r16
		lds r16, LCD_DATA2
		andi r16, $FE
		sts LCD_DATA2, r16 
		call LCD_SEND
		ret 

LCD_WRITE: 
		sts DATA, r16 
		ldi r20, $20 //Var r18 innan!
		call TWI_SEND 
		ret 

LCD_WAIT:
		push r24
		push r25
		ldi r24, $FF
		ldi r25, $CF
LCD_W1:
		sbiw r24, 1
		brne LCD_W1
		pop r25
		pop r24
		ret         

LCD_CLEAR: 
		ldi r16, LCD_CLR
		call LCD_COMMAND
		call LCD_WAIT
		ret

LCD_HOME: 
		ldi r16, HOME
		call LCD_COMMAND
		ret

LCD_SEND_PREP:
		mov r17, r16
		andi r16, $FD 
		ori r16, $08 
		sts LCD_DATA, r16
		swap r17
		andi r17, $FD
		ori r17, $08 
		sts LCD_DATA2, r17
		ret

LCD_SEND: 
		call LCD_WRITE4
		lds r16, LCD_DATA2
		sts LCD_DATA, r16 
		call LCD_WRITE4
		ret

LCD_WRITE4:
        call LCD_E_LOW
        call LCD_E_HIGH
		call LCD_E_LOW
		ret

LCD_E_LOW:
		lds r16, LCD_DATA
		andi r16, $FB //NO- LIST: $DF
		call LCD_WRITE
		ret

LCD_E_HIGH: 
		lds r16, LCD_DATA
		ori r16, $0C//PROBLEM HÄR! NO- LIST: $04, $0C, $20 
		call LCD_WRITE
		ret

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//TWI
TWI_SEND:
		ldi		r16,(1<<TWINT) | (1<<TWSTA) | (1<<TWEN)		// Send start
		sts		TWCR, r16 
		call	W_WAIT2 // vill inte göra tx delen 			
		
LOAD_SLA_W:
			lsl		r20
			sts		TWDR, r20 //lds först
			call	TX

LOAD_DATA:
			lds		r16, DATA	// Load data till TWDR register. clear TWINT bit in TWCR för att påbörja överföring av data // kommmer nog behöva vara lds när det tas från sram 
			sts		TWDR, r16
			call	TX

W_STOP:
			ldi		r16, (1<<TWINT) | (1<<TWEN) | (1<<TWSTO)
			sts		TWCR, r16
			ret

TX:
			ldi		r16, (1<<TWINT) | (1<<TWEN)
			sts		TWCR, r16

W_WAIT2: //stega igenom
			lds		r24,TWCR	// WAIT for TWINT flag set, betyder att SLA+W har skickats och ACK/NACK har tagits emot
			sbrs	r24,TWINT
			rjmp	W_WAIT2
			ret

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//Delay 0.5 second
DELAY_HALFSECOND:                 ; For CLK(CPU) = 1 MHz
    ldi     r16,31     ; One clock cycle;
DELAY1_TWO:
    ldi     r17,250     ; One clock cycle
DELAY2_TWO:
    ldi     r18,255     ; One clock cycle
DELAY3_TWO:
    dec     r18            ; One clock cycle
    nop                     ; One clock cycle
    brne    Delay3_TWO         ; Two clock cycles when jumping to Delay3, 1 clock when continuing to DEC

    dec     r17            ; One clock cycle
    brne    Delay2_TWO          ; Two clock cycles when jumping to Delay2, 1 clock when continuing to DEC

    dec     r16            ; One clock Cycle
    brne    Delay1_TWO          ; Two clock cycles when jumping to Delay1, 1 clock when continuing to RET
	ret


//Delay 0.25 second
DELAY_HALFHALF:                 ; For CLK(CPU) = 1 MHz
    ldi     r16,16     ; One clock cycle;
DELAY1_THREE:
    ldi     r17,245    ; One clock cycle
DELAY2_THREE:
    ldi     r18,255     ; One clock cycle
DELAY3_THREE:
    dec     r18            ; One clock cycle
    nop                     ; One clock cycle
    brne    Delay3_THREE          ; Two clock cycles when jumping to Delay3, 1 clock when continuing to DEC

    dec     r17            ; One clock cycle
    brne    Delay2_THREE          ; Two clock cycles when jumping to Delay2, 1 clock when continuing to DEC

    dec     r16            ; One clock Cycle
    brne    Delay1_THREE          ; Two clock cycles when jumping to Delay1, 1 clock when continuing to RET
	ret
///////////////////////////////////////////////////////////////////////////////////////////////////////////
LOAD_FLOOR: 
	ldi		ZH, HIGH(FLOOR*2)
	ldi		ZL, LOW(FLOOR*2)
	ldi		r18, 12
	ret

LOAD_OBSTICLE:
	ldi		ZH, HIGH(OBSTICLE*2)
	ldi		ZL, LOW(OBSTICLE*2)
	ldi		r18, 12
	ret 

LOAD_DINO_IDLE: 
	ldi ZH, HIGH(DINO_IDLE*2)
	ldi ZL, LOW(DINO_IDLE*2)
	ldi r18, 12
	ret 

LOAD_DINO_JUMP1:
	ldi ZH, HIGH(DINO_JUMP1*2)
	ldi ZL, LOW(DINO_JUMP1*2)
	ldi r18, 12
	ret
	
LOAD_DINO_JUMP2:
	ldi ZH, HIGH(DINO_JUMP2*2)
	ldi ZL, LOW(DINO_JUMP2*2)
	ldi r18, 12
	ret 
	
LOAD_DINO_JUMP3:
	ldi ZH, HIGH(DINO_JUMP3*2)
	ldi ZL, LOW(DINO_JUMP3*2)
	ldi r18, 12
	ret  

SPI_TRANSMIT:
// push r16
out SPDR, r16

// jmp WAIT_TRANSMIT

WAIT_TRANSMIT:
in r16,SPSR
sbrs r16, SPIF
rjmp WAIT_TRANSMIT
ret




SEND_MATRIX:
lpm r16, Z+
dec r18
cpi r18,0
call SPI_TRANSMIT
brne SEND_MATRIX
call SPI_SEND
ret

SPI_SEND:
sbi PORTB,PB2
nop
cbi PORTB,PB2
ret

SHORT_WAIT:
adiw r24,8 //1ms
brne SHORT_WAIT
ret
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//SRAM - CLEAR
CLEAR_SCREEN: 
		ldi r18, 12
SCREEN_CLEAR_LOOP: 
	    ldi r16, $00
	    dec r18
		cpi r18, $00
		call SPI_TRANSMIT
		brne SCREEN_CLEAR_LOOP
		call SPI_SEND 
		ret

SRAMCLEAR:
		push r17
		push r18
		ldi r17, 72
		ldi r18, 11
		ldi ZH, HIGH(VMEM*2)
		ldi ZL, LOW(VMEM*2) 
SRAMCLEARLOOP:
		dec r17
		st Z+, r18
		cpi r17, 0
		brne SRAMCLEARLOOP
		pop r18 
		pop r17
		ret 
